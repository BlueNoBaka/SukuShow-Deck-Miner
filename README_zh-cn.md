# SukuShow Deck Miner

适用于 [Link！Like！LoveLive！](https://www.lovelive-anime.jp/hasunosora/system/) (リンクラ) 中的音游模式 School Idol Show (スクショウ) 的卡组模拟器和优化求解器。 

---

**[English](README.md) | [简体中文](README_zh-cn.md) | [日本語](README_ja-jp.md)**

---

## 🚀 快速开始

### 🛞 环境要求

- **Python 版本**:
  由于代码中使用了 `match ... case ...` 语句，项目**最低要求 Python 3.10**。  
  **为了获得最佳性能，强烈推荐使用 Python 3.11 或更高版本运行。**

- **依赖包**:  

  - `PyYAML`
  - `tqdm`

  可通过以下命令安装：

  ```bash
  pip install PyYAML tqdm
  ```

---

## 🎮 使用方式

### ▶ 运行核心脚本

根据需求选择并运行以下文件：

- `MainBatch.py`: **批量模拟**。输入卡池与课题曲，自动生成卡组并进行批量模拟，以寻找**单曲最优解**。
- `MainSingle.py`: **单次模拟**。输入特定卡组与课题曲，进行单次模拟并输出详细模拟过程。
- `multi_song_optimizer.py`: **多曲优化**。输入多首课题曲，利用 `MainBatch.py` 生成的卡组得分数据，寻找**多曲目的最优解**。

### ⚙ 个性化配置

可以根据需要调整以下文件中的配置：

- `CardLevelConfig.py`: 配置所有卡牌的**默认等级**和**个别卡牌的等级** (`CARD_CACHE`)。默认情况下，所有卡牌均设置为满级。
- `DeckGen.py`: 负责卡组生成逻辑。可以在此配置**卡牌冲突规则** (`CARD_CONFLICT_RULES`) 以实现卡组生成时的进一步剪枝优化。

---

## ⚠️ **重要警告：CPU 占用与稳定性** ⚠️

> [!CAUTION]  
> ⚠ **批量模拟默认会调用所有可用的 CPU 线程执行，且运行时 CPU 占用率通常高达 99% 以上。** ⚠  
> **存在 i5-13600KF 在满负荷运行一段时间后蓝屏的案例。**
>
> 如对 CPU 体质或散热没有自信，**强烈建议在批量模拟前采取以下措施**：
>
> - 对 CPU 进行**升压/降频**操作。
> - **减少模拟器调用的线程数**。
>
> 保险起见，可将 `MainBatch.py` 文件中的 `num_processes = os.cpu_count() or 1` 这行代码修改为 `num_processes = 12`。其中 `12` 可根据实际线程数替换为**小于 CPU 线程数的其他值**，降低性能压力。

- **资源考量**：理论上可以把所有卡牌都放进备选卡池进行批量模拟。然而，这需要**极其强大的 CPU 性能、巨大的内存容量和充裕的模拟时间**。由于可能出现不可预知的问题，**不建议**这样做。
- **内存堆积**：尽管批量模拟中卡组生成与模拟环节是流水线作业，一定程度上减轻了模拟器的内存压力，但**所有卡组的模拟结果在完成前会持续在内存中堆积**。因此，请勿在备选卡池中放入过多卡牌，以免造成内存溢出。

---

## 📝 备注与潜在误差

- 本模拟器采用**穷举法**生成卡组进行模拟。所找到的「单曲最优解」仅在**给定卡池范围、卡牌练度以及谱面难度**下成立。它是指在这些条件下，在谱面中的完全准确时机打出 **All Perfect** 或开局挂机至 10% 血以下（如果卡组包含 Party 吟子）并后续保持 All Perfect 的最优得分卡组。调整卡池、练度或谱面难度后，可能会得到不同的最优解。
- 同理，多曲最优解也会随卡池、练度、谱面难度等因素而变化。
- 模拟器能够有效**节约实战模拟的时间**，但很难一发入魂找到真正的**绝对最优卡组**。需要对卡牌效果具有一定理解才能充分发挥模拟器的作用。
- **最优卡组 ≠ 最优策略**。卡时间点逐帧凹分或是根据技能条件/效果卡练度的操作请各显神通。
- 在计算 **Grandprix Pt** 时，所有成员的季度等级均按 **10 级**计算，C 位成员（如果有）的解放倍率均按**满破 1.4 倍**计算。
- 由于模拟器**并非 1:1 完全复刻游戏逻辑**，模拟得分与实战不一致是正常现象。

### ⏰ 可能的误差来源

**逻辑不一致**  
未能完全复刻游戏原始逻辑，导致技能处理、分数计算的结果与实战存在较大出入。  
若能提供**实战录像、卡组练度、歌曲 Master Lv. 信息**，我可能会尝试核对一下是哪里不一致进行修复。

**长条判定点缺失**  
个别谱面在模拟器中的解析 note 数存在个位数的误差，且未在 `RChartPatch.py` 中人工修正。  
谱面中的**曲线长条**实际上是由多个短的直线长条拼接而成，但其在谱面文件中的记录的中间时间点与实际游戏中的判定点未必完全一致。实际游戏中会按照半拍的间隔重新分割长条时间点，`RChart.py` 中对这一功能进行了复刻，但由于**计算精度或计算方式不同**，导致个别长条会少一个判定点。

**时间处理误差**  
由于**浮点数精度问题**或是其他神秘原因（例如游戏中可能是每帧处理一次所有事件，而非基于每个事件的准确时间点处理）实际技能发动时机可能与模拟存在数十毫秒的偏差。极端情况下曾出现过模拟中在Fever开始前打出的卡牌在实战中晚于Fever开始才打出，导致电加成被Fever开始时触发的C位技能消耗的案例。

**判定时机**  
模拟器只会按谱面中的 `just` 时间点处理 note，无论判定是否为 Perfect。  
然而实战中的 note 判定存在**时间窗口**，在 AP 不足时会导致实战的技能发动时机略微提前/延后，极端情况下可能导致卡牌打出次数比模拟多/少一次。  
对于和 Fever 开始/结束时点在同一拍上的 note，实战凹一下都有机会吃到 Fever 的双倍 Voltage。但 note 在谱面中的记录的时间点一般比 Fever 切换的时间点多两位小数，导致模拟时不一定会在 Fever 内结算得分。  
下表为 Ver.4.0.1 时的判定时机，仅供参考：

<table>
  <thead>
    <tr>
      <th rowspan="2"><b>判定</b></th>
      <th colspan="3"><b>判定时机 (ms)</b></th>
    </tr>
    <tr>
      <th><i>Single / Hold</i></th>
      <th><i>Flick</i></th>
      <th><i>Trace</i></th>
    </tr>
  </thead>
  <tbody align="center">
    <tr>
      <td>Perfect</td>
      <td>0 ~ ±40</td>
      <td>0 ~ ±70</td>
      <td>0 ~ ±70</td>
    </tr>
    <tr>
      <td>Great</td>
      <td>±40 ~ ±70</td>
      <td>±70 ~ ±100</td>
      <td>－</td>
    </tr>
    <tr>
      <td>Good</td>
      <td>±70 ~ ±100</td>
      <td>点击但未上划</td>
      <td>－</td>
    </tr>
    <tr>
      <td>Bad</td>
      <td>±100 ~ ±125</td>
      <td>－</td>
      <td>－</td>
    </tr>
    <tr>
      <td>Miss</td>
      <td>±125 ~</td>
      <td>±100 ~</td>
      <td>±70 ~</td>
    </tr>
  </tbody>
</table>
